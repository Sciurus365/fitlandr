#' Estimate a 2D potential landscape from a vector field
#'
#' For `method = "simlandr"`, the landscape is constructed based on the generalized potential landscape by Wang et al (2008), implemented by the `simlandr` package. This function is a wraper of [sim_vf()] and [simlandr::make_3d_static()]. Use those two functions seperately for more customization.
#'
#' @param vf A `vectorfield` object estimated by [fit_2d_vf()].]
#' @param method The method used for landscape construction. Currently "simlandr" is the only possible choice.
#' @param .sim_vf_options Options controlling the vector field simulation. Should be generated by [sim_vf_options()].
#' @param .simlandr_options Options controlling the landscape construction. Should be generated by [simlandr_options()].
#' @export
fit_2d_vfld <- function(vf, method = "simlandr", .sim_vf_options = sim_vf_options(vf), .simlandr_options = simlandr_options(vf)) {
	method <- method[1]
	if(method == "simlandr") {
		simulation_output <- do.call(sim_vf, .sim_vf_options %>% lapply(rlang::eval_tidy, list(vf = vf, chains = .$chains)))
		return(do.call(simlandr::make_3d_static, c(list(output = simulation_output), .simlandr_options%>% lapply(rlang::eval_tidy, list(vf = vf)))))
	}
}


#' Simulation from vector fields
#'
#' Parallel computing based on `future` is supported. Use `future::plan("multisession")` to enable this.
#'
#' @inheritParams fit_2d_vfld
#' @param chains How many chains simulations should be performed?
#' @param length The simulation length for each chain.
#' @param discard How much of the starting part of each chain should be discarded? (Warming-up period.)
#' @param inits The initial values of each chain.
#' @export
sim_vf <- function(vf, chains = 10, length = 1e4, discard = 0.3, inits = matrix(c(
	stats::runif(chains, min = vf$x_start, max = vf$x_end),
	stats::runif(chains, min = vf$y_start, max = vf$y_end)
), ncol = 2)) {
	if (vf$method == "VFC") {
		f <- function(x) {
			v <- stats::predict(vf$VFCresult, x %>% normalize_v(vf$data_normalized)) %>% scale_up(vf$data_normalized)
			variance <- vf$VFCresult$sigma2 %>% scale_up2(vf$data_normalized)
			a <- matrix(c(variance, 0, 0, variance), nrow = 2)
			return(list(v = v, a = a))
		}
	} else if (vf$method == "MVKE") {
		f <- function(x) {
			result <- vf$MVKEresult(x %>% normalize_v(vf$data_normalized))
			v <- result$mu %>% scale_up(vf$data_normalized)
			a <- result$a %>% scale_up2(vf$data_normalized)
			return(list(v = v, a = a))
		}
	}

	force(inits)
  result <- future.apply::future_apply(inits, MARGIN = 1, FUN = sim_vf_single, f = f, length = length, simplify = FALSE, future.seed = TRUE, future.packages = "SparseVFC")
  # result <- furrr::future_map(inits %>% asplit(MARGIN = 1), .f = sim_vf_single, f = f, length = length, .options = furrr::furrr_options(seed = TRUE))
  result <- lapply(result, function(x) x[1:(nrow(x)*(1-discard)),]) %>% do.call(rbind, .)
  colnames(result) <- colnames(vf$data)
  return(result)
}

sim_vf_single <- function(init, f, length) {
  dim <- length(init)
  result <- matrix(NA_real_, nrow = length, ncol = dim)
  result[1, ] <- init
  for (i in 2:length) {
    prev <- result[i - 1, ]
    dyn <- f(prev)
    next_point <- prev + dyn$v + MASS::mvrnorm(mu = rep(0, dim), Sigma = dyn$a)
    result[i, ] <- next_point
  }
  return(result)
}



#' Options controlling the vector field simulation
#' @inheritParams fit_2d_vfld
#' @inheritParams sim_vf
#' @export
sim_vf_options <- function(vf, chains = 10, length = 1e4, discard = 0.3, inits = rlang::expr(matrix(c(
	stats::runif(chains, min = vf$x_start, max = vf$x_end),
	stats::runif(chains, min = vf$y_start, max = vf$y_end)
), ncol = 2))) {
	if(!missing(vf)) return(list(vf = vf, chains = chains, length = length, discard = discard, inits = eval(inits)))
	else return(list(vf = rlang::expr(vf), chains = chains, length = length, discard = discard, inits = inits))
}

#' Options controlling the landscape construction
#' @inheritParams fit_2d_vfld
#' @inheritParams simlandr::make_3d_static
#' @export
simlandr_options <- function(vf, x = rlang::expr(vf$x), y = rlang::expr(vf$y), n = 200, lims = rlang::expr(c(vf$x_start, vf$x_end, vf$y_start, vf$y_end)), Umax = 8, h = 0.1, kde_fun = "ks") {
	if(!missing(vf)) return(list(x = eval(x), y = eval(y), n = n, lims = eval(lims), Umax = Umax, h = h, kde_fun = kde_fun))
	else return(list(x = x, y = y, lims = lims, Umax = Umax, h = h))
}
