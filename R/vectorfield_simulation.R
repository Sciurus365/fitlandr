#' Estimate a 2D potential landscape from a vector field
#'
#' For `method = "simlandr"`, the landscape is constructed based on the generalized potential landscape by Wang et al (2008), implemented by the `simlandr` package. This function is a wraper of [sim_vf()] and [simlandr::make_3d_static()]. Use those two functions seperately for more customization.
#'
#' @param vf A `vectorfield` object estimated by [fit_2d_vf()].
#' @param method The method used for landscape construction. Currently "simlandr" is the only possible choice.
#' @param .sim_vf_options Options controlling the vector field simulation. Should be generated by [sim_vf_options()].
#' @param .simlandr_options Options controlling the landscape construction. Should be generated by [simlandr_options()].
#' @export
fit_2d_vfld <- function(vf, method = "simlandr", .sim_vf_options = sim_vf_options(vf), .simlandr_options = simlandr_options(vf)) {
	method <- method[1]
	if(method == "simlandr") {
		simulation_output <- do.call(sim_vf, .sim_vf_options %>% lapply(eval_pass_missing, list(vf = vf, chains = .$chains)))
		return(do.call(simlandr::make_3d_static, c(list(output = simulation_output), .simlandr_options%>% lapply(eval_pass_missing, list(vf = vf)))))
	}
}

eval_pass_missing <- function(expr, ...) {
	if(rlang::is_missing(expr)) return(rlang::missing_arg())
	return(rlang::eval_tidy(expr, ...))
}


#' Simulation from vector fields
#'
#' Parallel computing based on `future` is supported. Use `future::plan("multisession")` to enable this.
#'
#' @inheritParams fit_2d_vfld
#' @param noise Relative noise of the simulation. Set this smaller when the simulation is unstable (e.g., when the elements in the diffusion matrix are not finite), and set this larger when the simulation converges too slowly.
#' @param chains How many chains simulations should be performed?
#' @param length The simulation length for each chain.
#' @param discard How much of the starting part of each chain should be discarded? (Warming-up period.)
#' @param inits The initial values of each chain.
#' @export
sim_vf <- function(vf, noise = 1, chains = 10, length = 1e4, discard = 0.3, inits = matrix(c(
	stats::runif(chains, min = vf$x_start, max = vf$x_end),
	stats::runif(chains, min = vf$y_start, max = vf$y_end)
), ncol = 2)) {
	if (vf$method == "VFC") {
		f <- function(x) {
			v <- stats::predict(vf$VFCresult, x %>% normalize_v(vf$data_normalized)) %>% scale_up(vf$data_normalized)
			variance <- vf$VFCresult$sigma2 %>% scale_up2(vf$data_normalized)
			a <- matrix(c(variance, 0, 0, variance), nrow = 2)
			return(list(v = v, a = a))
		}
	} else if (vf$method == "MVKE") {
		f <- function(x) {
			result <- vf$MVKEresult(x %>% normalize_v(vf$data_normalized))
			v <- result$mu %>% scale_up(vf$data_normalized)
			a <- result$a %>% scale_up2(vf$data_normalized)
			return(list(v = v, a = a))
		}
	}

	force(inits)
  result <- future.apply::future_apply(inits, MARGIN = 1, FUN = sim_vf_single, f = f, length = length, noise = noise, simplify = FALSE, future.seed = TRUE, future.packages = "SparseVFC")
  # result <- furrr::future_map(inits %>% asplit(MARGIN = 1), .f = sim_vf_single, f = f, length = length, .options = furrr::furrr_options(seed = TRUE))
  result <- lapply(result, function(x) x[1:(nrow(x)*(1-discard)),]) %>% do.call(rbind, .)
  colnames(result) <- colnames(vf$data)
  return(result)
}

sim_vf_single <- function(init, f, length, noise) {
  dim <- length(init)
  result <- matrix(NA_real_, nrow = length, ncol = dim)
  result[1, ] <- init
  for (i in 2:length) {
    prev <- result[i - 1, ]
    dyn <- f(prev)
    next_point <- prev + dyn$v + MASS::mvrnorm(mu = rep(0, dim), Sigma = dyn$a * noise)
    result[i, ] <- next_point
  }
  return(result)
}



#' Options controlling the vector field simulation
#' See [sim_vf()] for details.
#' @inheritParams fit_2d_vfld
#' @inheritParams sim_vf
#' @export
sim_vf_options <- function(vf, noise = 1, chains = 10, length = 1e4, discard = 0.3, inits = rlang::expr(matrix(c(
	stats::runif(chains, min = vf$x_start, max = vf$x_end),
	stats::runif(chains, min = vf$y_start, max = vf$y_end)
), ncol = 2))) {
	if(!missing(vf)) return(list(vf = vf, noise = noise, chains = chains, length = length, discard = discard, inits = eval(inits)))
	else return(list(vf = rlang::expr(vf), noise = noise, chains = chains, length = length, discard = discard, inits = inits))
}

#' Options controlling the landscape construction
#'
#' To control the behavior of [simlandr::make_3d_static()], but with default values accomodated for `fitlandr`. See [simlandr::make_3d_static()] for details.
#' @inheritParams fit_2d_vfld
#' @inheritParams simlandr::make_3d_static
#' @export
simlandr_options <- function(vf, x = rlang::expr(vf$x), y = rlang::expr(vf$y), lims = rlang::expr(c(vf$x_start, vf$x_end, vf$y_start, vf$y_end)), kde_fun = c("ks", "MASS"), n = 200, adjust = 1, h, Umax = 5) {
	if(!missing(vf)) return(list(x = eval(x), y = eval(y), lims = eval(lims), kde_fun = kde_fun, n = n, adjust = adjust, h = rlang::maybe_missing(h), Umax = Umax))
	else return(list(x = x, y = y, lims = lims, kde_fun = kde_fun, n = n, adjust = adjust, h = rlang::maybe_missing(h), Umax = Umax))
}
