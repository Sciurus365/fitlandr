#' Plot a 2D vector field
#'
#' Plot a 2D vector field estimated by [fit_2d_vf()]. Powered by [ggplot2::ggplot()].
#'
#' @param x A `vectorfield` object estimated by [fit_2d_vf()].
#' @param arrow The description of the arrow heads of the vectors on the plot (representing the vector field). Generated by [grid::arrow()]. Also see the `arrow` parameter of [ggplot2::geom_segment()].
#' @param estimated_vector_enlarge A number. How many times should the vectors (representing the estimated vector field) be enlarged on the plot? This can be useful when the estimated vector field is too strong or too weak.
#' @param estimated_vector_options A list passing other customized parameters to [ggplot2::geom_segment()] to control the vectors representing the estimated vector field.
#' @param show_point Show the original data points? `TRUE` by default.
#' @param point_options A list passing other customized parameters to [ggplot2::geom_point()] to control the points representing the original data point.
#' @param show_original_vector Show the original vectors (i.e., the vectors between data points)? `FALSE` by default.
#' @param original_vector_enlarge A number. How many times should the original vectors be enlarged on the plot?
#' @param original_vector_options A list passing other customized parameters to [ggplot2::geom_segment()] to control the vectors representing the original data.
#' @param show_used_vector Only for vector fields estimated by the "VFC" method. Should the vectors from the original data that are considered inliers be specially marked? `FALSE` by default.
#' @param used_vector_options Only for vector fields estimated by the "VFC" method. A list passing other customized parameters to [ggplot2::geom_segment()] to control the vectors representing the inliers. Red by default.
#' @param ... Not in use.
#'
#' @export
plot.vectorfield <- function(x, arrow = grid::arrow(length = grid::unit(0.1, "cm")),
                             estimated_vector_enlarge = 1,
                             estimated_vector_options = list(),
                             show_point = TRUE,
                             point_options = list(size = 0.5),
                             show_original_vector = FALSE,
                             original_vector_enlarge = 1,
                             original_vector_options = list(),
                             show_used_vector = FALSE,
                             used_vector_options = list(color = "red"),
                             ...) {
  p <-
    ggplot2::ggplot(x$vec_grid, ggplot2::aes(x = x, y = y)) +
    do.call(
      ggplot2::geom_segment,
      c(
        list(
          mapping = ggplot2::aes(
            xend = x + vx * estimated_vector_enlarge,
            yend = y + vy * estimated_vector_enlarge
          ),
          arrow = arrow
        ),
        estimated_vector_options
      )
    ) +
    ggplot2::theme_bw() +
    ggplot2::labs(x = x$x, y = x$y)

  if (show_point) {
    p <- p +
      do.call(
        ggplot2::geom_point,
        c(
          list(
            data = x$data %>% as.data.frame(),
            mapping = ggplot2::aes(x = .data[[x$x]], y = .data[[x$y]])
          ),
          point_options
        )
      )
  }

  if (show_original_vector) {
    p <- p +
      do.call(
        ggplot2::geom_segment,
        c(
          list(
            data = x$original_vectors %>% as.data.frame(),
            mapping = ggplot2::aes(
              x = x,
              y = y,
              xend = x + vx * original_vector_enlarge,
              yend = y + vy * original_vector_enlarge
            ),
            arrow = arrow
          ),
          original_vector_options
        )
      )
  }

  if (show_used_vector) {
    p <- p +
      do.call(
        ggplot2::geom_segment,
        c(
          list(
            data = x$original_vectors[x$VFCresult$VFCIndex, ] %>% as.data.frame(),
            mapping = ggplot2::aes(
              x = x,
              y = y,
              xend = x + vx * original_vector_enlarge,
              yend = y + vy * original_vector_enlarge
            ),
            arrow = arrow
          ),
          used_vector_options
        )
      )
  }

  return(p)
}

#' Plot a 2D landscape estimated from a vector field.
#'
#' Plot a 2D landscape estimated by [fit_2d_vfld()]. Powered by [ggplot2::ggplot()].
#'
#' @param x A `2d_vf_landscape` object created by [fit_2d_vfld()].
#' @param vectorfield Should the vector field also be plotted? If so, the landscape will be ploted below the vector field. `FALSE` by default.
#' @param type One of "landscape" or "error".
#' @param ... Other parameters passed to [plot.vectorfield()].
#'
#' @export
plot.2d_vf_landscape <- function(x, vectorfield = FALSE, type = c("landscape", "error"), ...) {
  if (vectorfield) {
    p <- plot(x$vf, ...)
  } else {
    p <- ggplot2::ggplot()
  }
  type <- type[1]
  if (type == "landscape") {
    dist_used <- x$dist
  } else if (type == "error") {
    dist_used <- x$dist_error
  } else {
    stop('`type` must be one of "landscape" or "error"')
  }
  p <- p -
    ggplot2::geom_raster(ggplot2::aes(x = x, y = y, fill = z), data = dist_used) +
    ggplot2::labs(fill = "U") +
    ggplot2::theme_bw()
  if (type == "landscape") {
  	p <- p + ggplot2::scale_fill_viridis_c()
  }
  if (type == "error") {
  	p <- p + ggplot2::scale_fill_gradientn(colours = colorRamps::green2red(15), limits = c(0,1))
  }
  p
}

#' @references krassowski's answer at https://stackoverflow.com/questions/20249653/insert-layer-underneath-existing-layers-in-ggplot2-object
`-.gg` <- function(plot, layer) {
  if (missing(layer)) {
    stop("Cannot use `-.gg()` with a single argument. Did you accidentally put - on a new line?")
  }
  if (!ggplot2::is.ggplot(plot)) {
    stop("Need a plot on the left side")
  }
  plot$layers <- c(layer, plot$layers)
  plot
}
